# Design Document: Todo Application

## Overview

The Todo Application is a minimal mobile app built with React Native and Expo that allows users to manage personal tasks with cloud synchronization. The design follows the ShipNative architecture patterns, using Supabase for backend storage and authentication, React Query for data fetching, Zustand for local state management, and Unistyles for theme-aware styling.

### Key Design Principles

- **Simplicity**: Minimal UI with essential features only
- **Cloud Sync**: Automatic synchronization across devices via Supabase
- **Authentication**: User accounts required for data isolation
- **Reactivity**: Real-time updates using Supabase subscriptions
- **Accessibility**: Support for dark mode and internationalization
- **Type Safety**: Full TypeScript coverage with strict mode

### Authentication Requirement

Users must be authenticated to use the todo app. This ensures:
- Data isolation (users only see their own todos)
- Cloud backup and sync across devices
- Row Level Security (RLS) in Supabase

## Architecture

### Component Hierarchy

```
TodoScreen (Screen)
├── TextField (Input for new todos)
├── Button (Add todo button)
├── EmptyState (When no todos exist)
└── FlatList (Todo items)
    └── TodoItem (Individual todo component)
        ├── Checkbox (Toggle completion)
        ├── Text (Task description)
        ├── Button (Edit action)
        └── Button (Delete action)
```

### State Management

**React Query** (Server State):
- Fetches todos from Supabase
- Manages loading, error, and success states
- Handles cache invalidation and refetching
- Optimistic updates for better UX

**Zustand Store** (`todoStore.ts`) (Optional Local State):
- Can be used for UI state (edit mode, filters)
- Not required for data storage (Supabase handles this)

**Supabase Realtime**:
- Subscribes to todo table changes
- Automatically updates UI when data changes on server
- Enables multi-device sync

### Data Flow

1. **User Action** → Component event handler
2. **Component** → Calls React Query mutation
3. **Mutation** → Sends request to Supabase
4. **Supabase** → Updates PostgreSQL database
5. **Supabase Realtime** → Broadcasts change to all subscribed clients
6. **React Query** → Invalidates cache and refetches
7. **Component** → Re-renders with new data

## Components and Interfaces

### Core Types

```typescript
// apps/app/app/types/todo.ts

export interface Todo {
  id: string              // UUID v4 (generated by Supabase)
  user_id: string         // Foreign key to auth.users
  description: string     // Task description (1-500 chars)
  completed: boolean      // Completion status
  created_at: string      // ISO 8601 timestamp
  updated_at: string      // ISO 8601 timestamp
}

// Supabase table schema
export interface TodoTable {
  Row: Todo
  Insert: Omit<Todo, 'id' | 'created_at' | 'updated_at'>
  Update: Partial<Omit<Todo, 'id' | 'user_id' | 'created_at'>>
}
```

### Database Schema (Supabase)

**Table**: `todos`

**SQL Schema**:
```sql
create table todos (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id) on delete cascade not null,
  description text not null check (char_length(description) between 1 and 500),
  completed boolean default false not null,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null
);

-- Row Level Security
alter table todos enable row level security;

-- Users can only see their own todos
create policy "Users can view own todos"
  on todos for select
  using (auth.uid() = user_id);

-- Users can insert their own todos
create policy "Users can insert own todos"
  on todos for insert
  with check (auth.uid() = user_id);

-- Users can update their own todos
create policy "Users can update own todos"
  on todos for update
  using (auth.uid() = user_id);

-- Users can delete their own todos
create policy "Users can delete own todos"
  on todos for delete
  using (auth.uid() = user_id);

-- Index for performance
create index todos_user_id_idx on todos(user_id);
create index todos_completed_idx on todos(completed);

-- Updated_at trigger
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger update_todos_updated_at
  before update on todos
  for each row
  execute function update_updated_at_column();
```

### React Query Hooks

**Location**: `apps/app/app/hooks/useTodos.ts`

**Custom Hooks**:

1. **useTodos()** - Fetch all todos for current user
```typescript
export function useTodos() {
  const { user } = useAuth()
  
  return useQuery({
    queryKey: ['todos', user?.id],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('todos')
        .select('*')
        .order('completed', { ascending: true })
        .order('created_at', { ascending: false })
      
      if (error) throw error
      return data as Todo[]
    },
    enabled: !!user,
  })
}
```

2. **useAddTodo()** - Add new todo
```typescript
export function useAddTodo() {
  const { user } = useAuth()
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: async (description: string) => {
      const trimmed = description.trim()
      if (!trimmed) throw new Error('Description cannot be empty')
      
      const { data, error } = await supabase
        .from('todos')
        .insert({ user_id: user!.id, description: trimmed })
        .select()
        .single()
      
      if (error) throw error
      return data as Todo
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })
}
```

3. **useToggleTodo()** - Toggle completion status
```typescript
export function useToggleTodo() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: async ({ id, completed }: { id: string; completed: boolean }) => {
      const { data, error } = await supabase
        .from('todos')
        .update({ completed: !completed })
        .eq('id', id)
        .select()
        .single()
      
      if (error) throw error
      return data as Todo
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })
}
```

4. **useUpdateTodo()** - Update description
```typescript
export function useUpdateTodo() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: async ({ id, description }: { id: string; description: string }) => {
      const trimmed = description.trim()
      if (!trimmed) throw new Error('Description cannot be empty')
      
      const { data, error } = await supabase
        .from('todos')
        .update({ description: trimmed })
        .eq('id', id)
        .select()
        .single()
      
      if (error) throw error
      return data as Todo
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })
}
```

5. **useDeleteTodo()** - Delete todo
```typescript
export function useDeleteTodo() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from('todos')
        .delete()
        .eq('id', id)
      
      if (error) throw error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })
}
```

6. **useTodosRealtime()** - Subscribe to realtime updates
```typescript
export function useTodosRealtime() {
  const { user } = useAuth()
  const queryClient = useQueryClient()
  
  useEffect(() => {
    if (!user) return
    
    const channel = supabase
      .channel('todos-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'todos',
          filter: `user_id=eq.${user.id}`,
        },
        () => {
          queryClient.invalidateQueries({ queryKey: ['todos'] })
        }
      )
      .subscribe()
    
    return () => {
      supabase.removeChannel(channel)
    }
  }, [user, queryClient])
}
```

### TodoScreen Component

**Location**: `apps/app/app/screens/TodoScreen.tsx`

**Responsibilities**:
- Render the main todo list interface
- Handle input for new todos
- Fetch todos from Supabase using React Query
- Subscribe to realtime updates
- Display empty state when no todos exist
- Handle authentication state

**Key Features**:
- Uses `Screen` component wrapper for consistent layout
- Uses `TextField` with translation keys for input
- Uses `EmptyState` component when list is empty
- Uses `FlatList` for efficient rendering of todo items
- Uses `useAuth()` to get current user
- Uses `useQuery` to fetch todos
- Uses `useMutation` for CRUD operations
- Uses Supabase realtime subscription for live updates

### TodoItem Component

**Location**: `apps/app/app/components/TodoItem.tsx`

**Responsibilities**:
- Render individual todo item
- Handle completion toggle
- Handle edit mode (inline editing)
- Handle delete action

**Props**:
```typescript
interface TodoItemProps {
  todo: Todo
  onToggle: (id: string) => void
  onUpdate: (id: string, description: string) => void
  onDelete: (id: string) => void
}
```

**States**:
- `isEditing`: boolean - Whether item is in edit mode
- `editText`: string - Temporary text during editing

## Data Models

### Todo Item Structure

```typescript
{
  id: "550e8400-e29b-41d4-a716-446655440000",  // UUID v4 (Supabase generated)
  user_id: "123e4567-e89b-12d3-a456-426614174000", // User's UUID
  description: "Buy groceries",                 // 1-500 characters
  completed: false,                             // boolean
  created_at: "2024-01-01T12:00:00.000Z",      // ISO 8601 timestamp
  updated_at: "2024-01-01T12:00:00.000Z"       // ISO 8601 timestamp
}
```

### Database Schema

**Table**: `todos`

| Column | Type | Constraints |
|--------|------|-------------|
| id | uuid | PRIMARY KEY, default gen_random_uuid() |
| user_id | uuid | FOREIGN KEY → auth.users(id), NOT NULL |
| description | text | NOT NULL, CHECK (length 1-500) |
| completed | boolean | NOT NULL, default false |
| created_at | timestamptz | NOT NULL, default now() |
| updated_at | timestamptz | NOT NULL, default now() |

**Indexes**:
- `todos_user_id_idx` on `user_id` (for filtering by user)
- `todos_completed_idx` on `completed` (for sorting)

**Row Level Security (RLS)**:
- Users can only access their own todos (filtered by `user_id`)
- All operations (SELECT, INSERT, UPDATE, DELETE) require `auth.uid() = user_id`

### Validation Rules

**Description** (validated in application code):
- Minimum length: 1 character (after trim)
- Maximum length: 500 characters (enforced by database constraint)
- Must not be only whitespace
- Trimmed before storage

**ID** (automatic - no validation needed):
- Generated by Supabase using `gen_random_uuid()`
- Always valid UUID v4 format

**User ID** (automatic - enforced by RLS):
- Automatically set to authenticated user's ID
- RLS policies prevent accessing other users' todos
- No manual validation needed

**Timestamps** (automatic - managed by Supabase):
- ISO 8601 format with timezone
- `created_at`: Set automatically on insert
- `updated_at`: Updated automatically by database trigger

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system—essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*

### Property 1: Adding valid tasks increases list size

*For any* valid task description (non-whitespace string), adding it to the task list should result in the task list length increasing by one and the new task appearing in the list.

**Validates: Requirements 1.1**

### Property 2: Whitespace-only tasks are rejected

*For any* string composed entirely of whitespace characters (spaces, tabs, newlines, or combinations), attempting to add it as a task should be rejected, and the task list should remain unchanged.

**Validates: Requirements 1.2**

### Property 3: All stored todos are displayed on startup

*For any* set of todos stored in Supabase for the authenticated user, when the application starts and fetches the todos, all stored todos should appear in the displayed task list.

**Validates: Requirements 2.1**

### Property 4: Rendered todos contain description and completion status

*For any* todo item, the rendered output should include both the task description text and a visual indicator of the completion status.

**Validates: Requirements 2.3**

### Property 5: Toggling completion status flips the boolean and reorders list

*For any* todo item, toggling its completion status should flip the boolean value (true → false, false → true), update the visual appearance accordingly, and move completed todos to the bottom of the list while keeping incomplete todos at the top.

**Validates: Requirements 3.1, 3.2**

### Property 6: Editing and saving updates the description

*For any* todo item and any valid new description, entering edit mode, changing the description, and saving should result in the todo having the new description.

**Validates: Requirements 4.1, 4.2**

### Property 7: Editing with whitespace preserves original description

*For any* todo item, if a user attempts to save an edit with only whitespace characters, the original description should be preserved unchanged.

**Validates: Requirements 4.3**

### Property 8: Canceling edit restores original description

*For any* todo item, if a user enters edit mode, makes changes, and then cancels, the original description should be restored exactly as it was before editing began.

**Validates: Requirements 4.4**

### Property 9: Deleting a todo removes it from the list

*For any* todo item in the task list, deleting it should result in that todo no longer appearing in the task list.

**Validates: Requirements 5.1**

### Property 10: Supabase round-trip preserves todos

*For any* set of todos, saving them to Supabase and then fetching them back should produce an equivalent set of todos with all data intact (ids, descriptions, completion status, user_id).

**Validates: Data persistence requirement (implicit)**

## UI/UX Behavior (Non-Core Properties)

These behaviors improve user experience but are not core correctness properties. They should be tested with unit/integration tests rather than property-based tests.

### UI Behavior 1: Input field cleared after adding task

After successfully adding a task, the input field should be empty and ready for the next entry.

**Validates: Requirements 1.3**
**Test approach**: Unit test with specific example


## Error Handling

### Network Errors

**Supabase Connection Failures**:
- Catch network errors when fetching/mutating todos
- Log error using `Logger.error()`
- Display toast notification using translation key `todoScreen.errorNetwork`
- React Query automatically retries failed requests (3 attempts)
- Show cached data while offline (stale-while-revalidate)

**Supabase Query Failures**:
- Catch Supabase errors (e.g., RLS violations, constraint violations)
- Log error with details
- Display user-friendly error message
- Use translation key `todoScreen.errorServer`

### Authentication Errors

**Unauthenticated User**:
- Redirect to login screen if user is not authenticated
- Display message using translation key `todoScreen.errorAuth`
- Prevent any todo operations until authenticated

**Session Expired**:
- Detect expired session
- Prompt user to re-authenticate
- Preserve any pending changes if possible

### Validation Errors

**Invalid Description**:
- Trim input before validation
- Check for empty string after trim
- Display inline error using `TextField` error prop
- Use translation key `todoScreen.errorEmptyTask`

**Description Too Long**:
- Check length <= 500 characters
- Display inline error
- Use translation key `todoScreen.errorTaskTooLong`

### UI Error States

**Empty State**:
- Display `EmptyState` component when no todos exist
- Use translation keys for heading and content
- Provide clear call-to-action

**Loading State**:
- Display `Spinner` while fetching todos
- Use skeleton loaders for better UX

**Error State**:
- Display error message when query fails
- Provide retry button
- Use translation key `todoScreen.errorRetry`

### Error Recovery

**Offline Mode**:
- React Query caches data for offline **viewing**
- Display cached todos when offline (read-only)
- Disable add/edit/delete actions when offline
- Show offline indicator banner
- Mutations will fail with network error if attempted offline
- User must be online to make changes

**Optimistic Updates** (Optional):
- Can be added for better UX when online
- Update UI immediately before server confirms
- Rollback on error
- Show toast notification if rollback occurs

**Partial Failures**:
- If some operations fail, show which ones
- Allow user to retry failed operations
- Don't block successful operations

## Testing Strategy

### Unit Tests

**Location**: `apps/app/app/__tests__/`

**Test Files**:
- `useTodos.test.ts` - React Query hooks
- `TodoItem.test.tsx` - Component rendering and interactions
- `TodoScreen.test.tsx` - Screen integration

**Unit Test Focus**:
- Specific examples demonstrating correct behavior
- Edge cases (empty strings, very long descriptions, special characters)
- Error conditions (network failures, auth errors, validation errors)
- Component rendering with different props
- Integration between components and hooks

**Example Unit Tests**:
```typescript
describe('useTodos hooks', () => {
  it('should add a todo with valid description', async () => {
    const { result } = renderHook(() => useAddTodo())
    
    await act(async () => {
      await result.current.mutateAsync('Buy milk')
    })
    
    expect(result.current.isSuccess).toBe(true)
  })
  
  it('should reject empty description', async () => {
    const { result } = renderHook(() => useAddTodo())
    
    await expect(
      result.current.mutateAsync('   ')
    ).rejects.toThrow('Description cannot be empty')
  })
  
  it('should handle network errors gracefully', async () => {
    // Mock Supabase to throw network error
    // Verify error is caught and logged
    // Verify user-friendly error message
  })
})
```

### Property-Based Tests

**Location**: `apps/app/app/__tests__/properties/`

**Test Files**:
- `todo.properties.test.ts` - All correctness properties

**Library**: `fast-check` (JavaScript/TypeScript property-based testing)

**Configuration**:
- Minimum 100 iterations per property test
- Each test tagged with feature name and property number
- Tag format: `Feature: todo-app, Property N: [property description]`

**Generators**:
```typescript
// Valid task descriptions (1-500 chars, non-whitespace)
const validDescription = fc.string({ minLength: 1, maxLength: 500 })
  .filter(s => s.trim().length > 0)

// Whitespace-only strings
const whitespaceString = fc.string()
  .map(s => s.replace(/\S/g, ' '))
  .filter(s => s.length > 0)

// Todo items
const todoArbitrary = fc.record({
  id: fc.uuid(),
  description: validDescription,
  completed: fc.boolean(),
  createdAt: fc.integer({ min: 0 }),
  updatedAt: fc.integer({ min: 0 })
})

// Arrays of todos
const todosArbitrary = fc.array(todoArbitrary, { maxLength: 50 })
```

**Example Property Tests**:
```typescript
describe('Property Tests', () => {
  it('Property 1: Adding valid tasks increases list size', () => {
    // Feature: todo-app, Property 1: Adding valid tasks increases list size
    fc.assert(
      fc.property(validDescription, async (description) => {
        const { result } = renderHook(() => useAddTodo())
        const { result: todosResult } = renderHook(() => useTodos())
        
        const initialLength = todosResult.current.data?.length || 0
        
        await act(async () => {
          await result.current.mutateAsync(description)
        })
        
        await waitFor(() => {
          expect(todosResult.current.data?.length).toBe(initialLength + 1)
        })
      }),
      { numRuns: 100 }
    )
  })
  
  it('Property 2: Whitespace-only tasks are rejected', () => {
    // Feature: todo-app, Property 2: Whitespace-only tasks are rejected
    fc.assert(
      fc.property(whitespaceString, async (description) => {
        const { result } = renderHook(() => useAddTodo())
        const { result: todosResult } = renderHook(() => useTodos())
        
        const initialTodos = todosResult.current.data || []
        
        await expect(
          result.current.mutateAsync(description)
        ).rejects.toThrow()
        
        await waitFor(() => {
          expect(todosResult.current.data).toEqual(initialTodos)
        })
      }),
      { numRuns: 100 }
    )
  })
  
  it('Property 11: Supabase round-trip preserves todos', () => {
    // Feature: todo-app, Property 11: Supabase round-trip preserves todos
    fc.assert(
      fc.property(todosArbitrary, async (todos) => {
        // Insert todos into Supabase
        for (const todo of todos) {
          await supabase.from('todos').insert(todo)
        }
        
        // Fetch todos from Supabase
        const { data } = await supabase.from('todos').select('*')
        
        // Verify todos match (ignoring timestamps which may differ slightly)
        expect(data?.map(t => t.description)).toEqual(
          todos.map(t => t.description)
        )
      }),
      { numRuns: 100 }
    )
  })
})
```

### Integration Tests

**Location**: `apps/app/app/__tests__/integration/`

**Test Files**:
- `todo-flow.test.tsx` - End-to-end user flows

**Focus**:
- Complete user workflows (add → complete → edit → delete)
- Authentication integration
- Supabase realtime updates
- Multi-device sync simulation
- Theme switching behavior
- Offline/online transitions

### Testing Balance

**Unit Tests**:
- Focus on specific examples and edge cases
- Test error conditions and boundary values
- Verify component rendering and styling
- Test React Query hooks in isolation
- Keep unit tests focused and minimal

**Property Tests**:
- Verify universal properties across all inputs
- Generate hundreds of random test cases
- Catch edge cases that unit tests might miss
- Ensure correctness across the input space
- Test Supabase integration with various data

**Integration Tests**:
- Test complete user workflows
- Verify authentication flow
- Test realtime synchronization
- Ensure end-to-end functionality
- Test offline/online behavior

### Test Coverage Goals

- **Hooks Logic**: 100% coverage (critical business logic)
- **Components**: 80%+ coverage (focus on logic, not styling)
- **Properties**: All 10 core correctness properties must have passing tests
- **UI Behaviors**: UI/UX behaviors tested with unit tests
- **Integration**: Cover all main user workflows
- **Supabase Integration**: Test all CRUD operations

### Running Tests

```bash
# Run all tests
yarn test

# Run tests in watch mode
yarn test:watch

# Run with coverage
yarn test:coverage

# Run only property tests
yarn test properties

# Run only unit tests
yarn test unit

# Run only integration tests
yarn test integration
```

## Translation Keys

All user-facing text must use translation keys defined in `apps/app/app/i18n/en.ts`:

```typescript
todoScreen: {
  // Screen title
  title: "My Todos",
  
  // Input field
  inputPlaceholder: "What needs to be done?",
  addButton: "Add",
  
  // Empty state
  emptyHeading: "No todos yet",
  emptyContent: "Add your first todo to get started",
  
  // Todo item actions
  editButton: "Edit",
  deleteButton: "Delete",
  saveButton: "Save",
  cancelButton: "Cancel",
  
  // Error messages
  errorEmptyTask: "Task description cannot be empty",
  errorTaskTooLong: "Task description is too long (max 500 characters)",
  errorNetwork: "Network error. Please check your connection.",
  errorServer: "Server error. Please try again later.",
  errorAuth: "Please sign in to manage your todos",
  errorRetry: "Retry",
  
  // Loading states
  loading: "Loading todos...",
  
  // Offline indicator
  offline: "You're offline. Changes will sync when you're back online.",
  
  // Accessibility labels
  toggleComplete: "Toggle completion status",
  todoItem: "Todo item",
}
```

## Styling Guidelines

### Theme Colors

Use semantic theme colors from Unistyles:

```typescript
const stylesheet = StyleSheet.create((theme) => ({
  container: {
    backgroundColor: theme.colors.background,
  },
  todoItem: {
    backgroundColor: theme.colors.surface,
    borderColor: theme.colors.border,
  },
  todoText: {
    color: theme.colors.text,
  },
  completedText: {
    color: theme.colors.textDim,
    textDecorationLine: 'line-through',
  },
  inputField: {
    backgroundColor: theme.colors.surface,
    borderColor: theme.colors.border,
  },
  deleteButton: {
    color: theme.colors.error,
  },
}))
```

### Spacing

Use theme spacing values:

```typescript
const stylesheet = StyleSheet.create((theme) => ({
  container: {
    padding: theme.spacing.md,
    gap: theme.spacing.sm,
  },
  todoItem: {
    padding: theme.spacing.sm,
    marginBottom: theme.spacing.xs,
  },
}))
```

### Dark Mode Support

All components automatically support dark mode through semantic theme colors. No additional logic needed.

## Implementation Notes

### Performance Considerations

- Use `FlatList` for todo list (efficient for large lists)
- Use `keyExtractor` with todo.id for stable keys
- Memoize `TodoItem` component with `React.memo()`
- React Query automatically handles caching and deduplication
- Supabase indexes on `user_id` and `completed` for fast queries
- Realtime subscription only for current user's todos (filtered by RLS)

### Offline Behavior

- **Read-only offline mode**: Users can view cached todos when offline
- **Mutations disabled**: Add/edit/delete buttons disabled when offline
- **Network detection**: Use `@react-native-community/netinfo` to detect connectivity
- **Offline indicator**: Show banner when offline
- **Error handling**: Show clear error message if mutation attempted offline

### Accessibility

- Use proper semantic HTML/RN elements
- Provide accessibility labels for icon buttons
- Ensure sufficient color contrast in both themes
- Support keyboard navigation (web)
- Test with screen readers

### Future Enhancements (Out of Scope)

- Offline mutation queue (advanced offline support)
- Todo categories/tags
- Due dates and reminders
- Search and filter
- Sorting options
- Sharing todos
- Recurring tasks
- Subtasks
- Collaborative todos (shared lists)
